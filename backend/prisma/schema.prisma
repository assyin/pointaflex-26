generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

model Tenant {
  id                        String                     @id @default(uuid())
  createdAt                 DateTime                   @default(now())
  updatedAt                 DateTime                   @updatedAt
  companyName               String
  slug                      String                     @unique
  logo                      String?
  email                     String
  phone                     String?
  address                   String?
  country                   String                     @default("MA")
  timezone                  String                     @default("Africa/Casablanca")
  city                      String?
  displayName               String?
  hrEmail                   String?
  language                  String                     @default("fr")
  legalName                 String?
  attendance                Attendance[]
  devices                   AttendanceDevice[]
  auditLogs                 AuditLog[]
  departments               Department[]
  positions                 Position[]
  employees                 Employee[]
  holidays                  Holiday[]
  leaves                    Leave[]
  leaveTypes                LeaveType[]
  notifications             Notification[]
  overtime                  Overtime[]
  recovery                  Recovery[]
  schedules                 Schedule[]
  shifts                    Shift[]
  shiftReplacements         ShiftReplacement[]
  sites                     Site[]
  teams                     Team[]
  siteManagers              SiteManager[]
  settings                  TenantSettings?
  users                     User[]
  userTenantRoles           UserTenantRole[]
  roles                     Role[] // Rôles personnalisés par tenant (optionnel)
  reportHistory             ReportHistory[]
  terminalMatriculeMappings TerminalMatriculeMapping[]
  RecoveryDay               RecoveryDay[]

  @@index([slug])
}

model TenantSettings {
  id                           String   @id @default(uuid())
  tenantId                     String   @unique
  workDaysPerWeek              Int      @default(6)
  maxWeeklyHours               Decimal  @default(44)
  breakDuration                Int      @default(60)
  alertWeeklyHoursExceeded     Boolean  @default(true)
  alertInsufficientRest        Boolean  @default(true)
  alertNightWorkRepetitive     Boolean  @default(true)
  alertMinimumStaffing         Boolean  @default(true)
  annualLeaveDays              Int      @default(18)
  leaveApprovalLevels          Int      @default(2)
  overtimeRate                 Decimal  @default(1.25)
  nightShiftRate               Decimal  @default(1.50)
  createdAt                    DateTime @default(now())
  updatedAt                    DateTime @updatedAt
  anticipatedLeave             Boolean  @default(false)
  earlyToleranceExit           Int      @default(5)
  firstDayOfWeek               String   @default("monday")
  lateToleranceEntry           Int      @default(10)
  monthlyPayrollEmail          Boolean  @default(false)
  nightShiftEnd                String   @default("06:00")
  nightShiftStart              String   @default("21:00")
  overtimeRounding             Int      @default(15)
  sfptExport                   Boolean  @default(false)
  twoLevelWorkflow             Boolean  @default(true)
  workingDays                  Json?
  recoveryConversionRate       Decimal  @default(1.0) // Taux de conversion heures supp -> récupération (1.0 = 1h supp = 1h récup)
  recoveryExpiryDays           Int      @default(90) // Nombre de jours avant expiration de la récupération
  dailyWorkingHours            Decimal  @default(7.33) // Nombre d'heures équivalent à une journée normale (par défaut: 44h/6j = 7.33h)
  requireBreakPunch            Boolean  @default(false) // Activer/désactiver le pointage des repos (pauses)
  temporaryMatriculeExpiryDays Int      @default(8) // Nombre de jours avant expiration du matricule temporaire (délai pour obtenir le matricule officiel)
  tenant                       Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@index([tenantId])
}

model User {
  id                  String           @id @default(uuid())
  createdAt           DateTime         @default(now())
  updatedAt           DateTime         @updatedAt
  tenantId            String? // Optionnel pour compatibilité, mais on utilisera UserTenantRole
  email               String           @unique // Email unique globalement
  password            String
  firstName           String
  lastName            String
  phone               String?
  avatar              String?
  isActive            Boolean          @default(true)
  lastLoginAt         DateTime?
  forcePasswordChange Boolean          @default(false) // Forcer changement mot de passe à la première connexion
  role                LegacyRole?      @default(EMPLOYEE) // Optionnel pour compatibilité
  auditLogs           AuditLog[]
  employee            Employee?
  tenant              Tenant?          @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  userTenantRoles     UserTenantRole[]
  preferences         UserPreferences?
  sessions            UserSession[]
  credentials         UserCredentials?
  reportHistory       ReportHistory[]

  @@index([tenantId])
  @@index([email])
}

model Employee {
  id                        String                     @id @default(uuid())
  createdAt                 DateTime                   @default(now())
  updatedAt                 DateTime                   @updatedAt
  tenantId                  String
  matricule                 String
  firstName                 String
  lastName                  String
  email                     String?
  phone                     String?
  dateOfBirth               DateTime?
  address                   String?
  photo                     String?
  civilite                  String?
  situationFamiliale        String?
  nombreEnfants             Int?
  cnss                      String?
  cin                       String?
  ville                     String?
  rib                       String?
  region                    String?
  categorie                 String?
  position                  String // Texte libre (legacy) - Gardé pour compatibilité
  positionId                String? // Relation vers Position (nouveau)
  hireDate                  DateTime
  contractType              String?
  siteId                    String?
  departmentId              String?
  teamId                    String?
  currentShiftId            String?
  fingerprintData           String?
  faceData                  String?
  rfidBadge                 String?
  qrCode                    String?
  pinCode                   String?
  isActive                  Boolean                    @default(true)
  userId                    String?                    @unique
  attendance                Attendance[]
  currentShift              Shift?                     @relation(fields: [currentShiftId], references: [id])
  department                Department?                @relation(fields: [departmentId], references: [id])
  positionRef               Position?                  @relation(fields: [positionId], references: [id])
  site                      Site?                      @relation(fields: [siteId], references: [id])
  team                      Team?                      @relation(fields: [teamId], references: [id])
  tenant                    Tenant                     @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  user                      User?                      @relation(fields: [userId], references: [id])
  leaves                    Leave[]
  notifications             Notification[]
  overtime                  Overtime[]
  recovery                  Recovery[]
  recoveryDays              RecoveryDay[]
  schedules                 Schedule[]
  replacementsAsOriginal    ShiftReplacement[]         @relation("OriginalEmployee")
  replacementsAsReplacement ShiftReplacement[]         @relation("ReplacementEmployee")
  managedTeams              Team[]                     @relation("TeamManager")
  managedSites              Site[]                     @relation("SiteManagerLegacy") // DEPRECATED
  managedDepartments        Department[]               @relation("DepartmentManager")
  siteManagements           SiteManager[] // Nouvelle relation: gestion de sites par département
  credentials               UserCredentials? // Credentials temporaires du compte d'accès
  terminalMatriculeMappings TerminalMatriculeMapping[] // Mappings matricule terminal -> matricule officiel

  @@unique([tenantId, matricule])
  @@index([tenantId])
  @@index([siteId])
  @@index([departmentId])
  @@index([teamId])
  @@index([positionId])
  @@index([isActive])
  @@index([tenantId, departmentId, isActive])
}

model TerminalMatriculeMapping {
  id                String   @id @default(uuid())
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt
  tenantId          String
  employeeId        String
  terminalMatricule String // Matricule utilisé sur le terminal (temporaire ou officiel)
  officialMatricule String // Matricule officiel dans le système
  deviceId          String? // ID du terminal (optionnel, si mapping par terminal)
  isActive          Boolean  @default(true)
  assignedAt        DateTime @default(now()) // Date d'assignation du matricule temporaire

  employee Employee @relation(fields: [employeeId], references: [id], onDelete: Cascade)
  tenant   Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@unique([tenantId, terminalMatricule]) // Un matricule terminal unique par tenant
  @@index([tenantId])
  @@index([employeeId])
  @@index([terminalMatricule])
  @@index([isActive])
}

model Site {
  id           String             @id @default(uuid())
  createdAt    DateTime           @default(now())
  updatedAt    DateTime           @updatedAt
  tenantId     String
  name         String
  address      String?
  city         String?
  latitude     Decimal?
  longitude    Decimal?
  code         String?
  phone        String?
  timezone     String?
  workingDays  Json?
  managerId    String? // DEPRECATED: Utiliser SiteManager à la place. Gardé pour rétrocompatibilité
  departmentId String? // ID du département principal du site
  manager      Employee?          @relation("SiteManagerLegacy", fields: [managerId], references: [id])
  department   Department?        @relation("SiteDepartment", fields: [departmentId], references: [id])
  attendance   Attendance[]
  devices      AttendanceDevice[]
  employees    Employee[]
  siteManagers SiteManager[] // Nouvelle relation: plusieurs managers par site (un par département)
  tenant       Tenant             @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@index([tenantId])
  @@index([tenantId, code])
  @@index([managerId])
  @@index([departmentId])
}

model Department {
  id           String        @id @default(uuid())
  createdAt    DateTime      @default(now())
  updatedAt    DateTime      @updatedAt
  tenantId     String
  name         String
  code         String?
  description  String?
  managerId    String? // ID du manager du département
  manager      Employee?     @relation("DepartmentManager", fields: [managerId], references: [id])
  tenant       Tenant        @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  employees    Employee[]
  sites        Site[]        @relation("SiteDepartment")
  siteManagers SiteManager[] // Managers régionaux de ce département dans différents sites

  @@index([tenantId])
  @@index([managerId])
}

// Table de liaison pour permettre plusieurs managers régionaux par site (un par département)
model SiteManager {
  id           String   @id @default(uuid())
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
  tenantId     String
  siteId       String
  managerId    String // ID du manager régional
  departmentId String // ID du département que ce manager gère dans ce site

  site       Site       @relation(fields: [siteId], references: [id], onDelete: Cascade)
  manager    Employee   @relation(fields: [managerId], references: [id], onDelete: Cascade)
  department Department @relation(fields: [departmentId], references: [id], onDelete: Cascade)
  tenant     Tenant     @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@unique([siteId, departmentId]) // Un seul manager par département par site
  @@index([tenantId])
  @@index([siteId])
  @@index([managerId])
  @@index([departmentId])
}

model Position {
  id          String     @id @default(uuid())
  createdAt   DateTime   @default(now())
  updatedAt   DateTime   @updatedAt
  tenantId    String
  name        String // Ex: "Développeur Full-Stack"
  code        String? // Ex: "DEV-FS"
  category    String? // Ex: "IT", "RH", "FINANCE", "PRODUCTION"
  description String?
  tenant      Tenant     @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  employees   Employee[]

  @@index([tenantId])
  @@index([category])
}

model Shift {
  id            String             @id @default(uuid())
  createdAt     DateTime           @default(now())
  updatedAt     DateTime           @updatedAt
  tenantId      String
  name          String
  code          String
  startTime     String
  endTime       String
  breakDuration Int                @default(60)
  isNightShift  Boolean            @default(false)
  color         String?
  employees     Employee[]
  schedules     Schedule[]
  tenant        Tenant             @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  replacements  ShiftReplacement[]

  @@index([tenantId])
}

model Team {
  id                String     @id @default(uuid())
  createdAt         DateTime   @default(now())
  updatedAt         DateTime   @updatedAt
  tenantId          String
  name              String
  code              String
  description       String?
  managerId         String?
  manager           Employee?  @relation("TeamManager", fields: [managerId], references: [id])
  rotationEnabled   Boolean    @default(false)
  rotationCycleDays Int?
  employees         Employee[]
  schedules         Schedule[]
  tenant            Tenant     @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@index([tenantId])
}

model Schedule {
  id              String   @id @default(uuid())
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  tenantId        String
  employeeId      String
  teamId          String?
  shiftId         String
  date            DateTime @db.Date
  customStartTime String?
  customEndTime   String?
  notes           String?
  employee        Employee @relation(fields: [employeeId], references: [id], onDelete: Cascade)
  shift           Shift    @relation(fields: [shiftId], references: [id])
  team            Team?    @relation(fields: [teamId], references: [id])
  tenant          Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@unique([employeeId, date])
  @@index([tenantId])
  @@index([date])
  @@index([employeeId])
}

model ShiftReplacement {
  id                    String            @id @default(uuid())
  createdAt             DateTime          @default(now())
  updatedAt             DateTime          @updatedAt
  tenantId              String
  date                  DateTime          @db.Date
  originalEmployeeId    String
  replacementEmployeeId String
  shiftId               String
  reason                String?
  status                ReplacementStatus @default(PENDING)
  approvedBy            String?
  approvedAt            DateTime?
  originalEmployee      Employee          @relation("OriginalEmployee", fields: [originalEmployeeId], references: [id])
  replacementEmployee   Employee          @relation("ReplacementEmployee", fields: [replacementEmployeeId], references: [id])
  shift                 Shift             @relation(fields: [shiftId], references: [id])
  tenant                Tenant            @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@index([tenantId])
  @@index([date])
}

model AttendanceDevice {
  id         String       @id @default(uuid())
  createdAt  DateTime     @default(now())
  updatedAt  DateTime     @updatedAt
  tenantId   String
  siteId     String?
  name       String
  deviceId   String       @unique
  deviceType DeviceType
  ipAddress  String?
  apiKey     String?
  isActive   Boolean      @default(true)
  lastSync   DateTime?
  attendance Attendance[]
  site       Site?        @relation(fields: [siteId], references: [id])
  tenant     Tenant       @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@index([tenantId])
}

model Attendance {
  id                String            @id @default(uuid())
  createdAt         DateTime          @default(now())
  updatedAt         DateTime          @updatedAt
  tenantId          String
  employeeId        String
  siteId            String?
  deviceId          String?
  timestamp         DateTime
  type              AttendanceType
  method            DeviceType
  latitude          Decimal?
  longitude         Decimal?
  hasAnomaly        Boolean           @default(false)
  anomalyType       String?
  anomalyNote       String?
  isCorrected       Boolean           @default(false)
  correctedBy       String?
  correctedAt       DateTime?
  correctionNote    String? // Note de correction
  hoursWorked       Decimal? // Heures travaillées calculées
  lateMinutes       Int? // Minutes de retard
  earlyLeaveMinutes Int? // Minutes de départ anticipé
  overtimeMinutes   Int? // Minutes d'heures supplémentaires
  needsApproval     Boolean           @default(false) // Nécessite approbation pour correction
  approvalStatus    String? // PENDING_APPROVAL, APPROVED, REJECTED
  approvedBy        String? // ID de l'utilisateur qui a approuvé
  approvedAt        DateTime? // Date d'approbation
  rawData           Json?
  generatedBy       String?
  isGenerated       Boolean           @default(false)
  device            AttendanceDevice? @relation(fields: [deviceId], references: [id])
  employee          Employee          @relation(fields: [employeeId], references: [id], onDelete: Cascade)
  site              Site?             @relation(fields: [siteId], references: [id])
  tenant            Tenant            @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@index([tenantId])
  @@index([employeeId])
  @@index([timestamp])
  @@index([hasAnomaly])
  @@index([needsApproval])
  @@index([tenantId, employeeId, timestamp])
}

model LeaveType {
  id               String   @id @default(uuid())
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt
  tenantId         String
  name             String
  code             String
  isPaid           Boolean  @default(true)
  requiresDocument Boolean  @default(false)
  maxDaysPerYear   Int?
  leaves           Leave[]
  tenant           Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@index([tenantId])
}

model Leave {
  id                 String      @id @default(uuid())
  createdAt          DateTime    @default(now())
  updatedAt          DateTime    @updatedAt
  tenantId           String
  employeeId         String
  leaveTypeId        String
  startDate          DateTime    @db.Date
  endDate            DateTime    @db.Date
  days               Decimal
  reason             String?
  document           String? // Chemin ou URL du fichier
  documentName       String? // Nom original du fichier
  documentSize       Int? // Taille en bytes
  documentMimeType   String? // Type MIME (application/pdf, etc.)
  documentUploadedBy String? // ID de l'utilisateur qui a uploadé
  documentUploadedAt DateTime? // Date d'upload
  documentUpdatedBy  String? // ID du dernier utilisateur qui a modifié
  documentUpdatedAt  DateTime? // Date de dernière modification
  status             LeaveStatus @default(PENDING)
  managerApprovedBy  String?
  managerApprovedAt  DateTime?
  managerComment     String?
  hrApprovedBy       String?
  hrApprovedAt       DateTime?
  hrComment          String?
  employee           Employee    @relation(fields: [employeeId], references: [id], onDelete: Cascade)
  leaveType          LeaveType   @relation(fields: [leaveTypeId], references: [id])
  tenant             Tenant      @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@index([tenantId])
  @@index([employeeId])
  @@index([startDate])
  @@index([tenantId, employeeId, startDate, endDate])
}

model Overtime {
  id                           String                @id @default(uuid())
  createdAt                    DateTime              @default(now())
  updatedAt                    DateTime              @updatedAt
  tenantId                     String
  employeeId                   String
  date                         DateTime              @db.Date
  hours                        Decimal
  approvedHours                Decimal? // Nombre d'heures validées par le manager (peut différer de hours)
  type                         OvertimeType          @default(STANDARD)
  isNightShift                 Boolean               @default(false) // DEPRECATED: Utiliser type à la place
  rate                         Decimal               @default(1.25)
  // Conversion en récupération (heures)
  convertedToRecovery          Boolean               @default(false)
  recoveryId                   String?
  convertedHoursToRecovery     Decimal               @default(0) // Heures converties en Recovery
  // Conversion en récupération (journées) - NOUVEAU
  convertedToRecoveryDays      Boolean               @default(false)
  convertedHoursToRecoveryDays Decimal               @default(0) // Heures converties en RecoveryDay
  status                       OvertimeStatus        @default(PENDING)
  approvedBy                   String?
  approvedAt                   DateTime?
  rejectionReason              String? // Raison du rejet si la demande est rejetée
  notes                        String? // Notes/justification de la demande
  employee                     Employee              @relation(fields: [employeeId], references: [id], onDelete: Cascade)
  tenant                       Tenant                @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  recoveryDays                 OvertimeRecoveryDay[] // Relations avec RecoveryDay

  @@index([tenantId])
  @@index([employeeId])
  @@index([status])
  @@index([type])
  @@index([tenantId, employeeId, date, status])
}

model Recovery {
  id             String    @id @default(uuid())
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt
  tenantId       String
  employeeId     String
  hours          Decimal
  source         String?
  usedHours      Decimal   @default(0)
  remainingHours Decimal
  expiryDate     DateTime?
  employee       Employee  @relation(fields: [employeeId], references: [id], onDelete: Cascade)
  tenant         Tenant    @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@index([tenantId])
  @@index([employeeId])
}

// NOUVEAU : Journées de récupération
model RecoveryDay {
  id              String                @id @default(uuid())
  createdAt       DateTime              @default(now())
  updatedAt       DateTime              @updatedAt
  tenantId        String
  employeeId      String
  startDate       DateTime              @db.Date
  endDate         DateTime              @db.Date
  days            Decimal
  sourceHours     Decimal // Heures supp utilisées pour cette récupération
  conversionRate  Decimal? // Taux utilisé (si différent du défaut)
  status          RecoveryDayStatus     @default(PENDING)
  approvedBy      String?
  approvedAt      DateTime?
  notes           String?
  employee        Employee              @relation(fields: [employeeId], references: [id], onDelete: Cascade)
  tenant          Tenant                @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  overtimeSources OvertimeRecoveryDay[]

  @@index([tenantId])
  @@index([employeeId])
  @@index([startDate])
  @@index([status])
}

// NOUVEAU : Table de liaison Overtime ↔ RecoveryDay
model OvertimeRecoveryDay {
  id            String      @id @default(uuid())
  overtimeId    String
  recoveryDayId String
  hoursUsed     Decimal // Nombre d'heures de cet overtime utilisées
  overtime      Overtime    @relation(fields: [overtimeId], references: [id], onDelete: Cascade)
  recoveryDay   RecoveryDay @relation(fields: [recoveryDayId], references: [id], onDelete: Cascade)

  @@unique([overtimeId, recoveryDayId])
  @@index([overtimeId])
  @@index([recoveryDayId])
}

enum RecoveryDayStatus {
  PENDING
  APPROVED
  USED
  CANCELLED
}

model Holiday {
  id          String      @id @default(uuid())
  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @updatedAt
  tenantId    String
  name        String
  date        DateTime    @db.Date
  isRecurring Boolean     @default(false)
  type        HolidayType @default(NATIONAL)
  tenant      Tenant      @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@index([tenantId])
  @@index([date])
}

model AuditLog {
  id        String   @id @default(uuid())
  createdAt DateTime @default(now())
  tenantId  String
  userId    String?
  action    String
  entity    String
  entityId  String?
  oldValues Json?
  newValues Json?
  ipAddress String?
  userAgent String?
  tenant    Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  user      User?    @relation(fields: [userId], references: [id])

  @@index([tenantId])
  @@index([createdAt])
  @@index([entity])
}

model Notification {
  id         String           @id @default(uuid())
  createdAt  DateTime         @default(now())
  updatedAt  DateTime         @updatedAt
  tenantId   String
  employeeId String
  type       NotificationType
  title      String
  message    String
  isRead     Boolean          @default(false)
  readAt     DateTime?
  metadata   Json?
  employee   Employee         @relation(fields: [employeeId], references: [id], onDelete: Cascade)
  tenant     Tenant           @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@index([tenantId])
  @@index([employeeId])
  @@index([isRead])
}

// ============================================
// RBAC Multi-Tenant Models
// ============================================

// Rôle : peut être système (SUPER_ADMIN) ou spécifique à un tenant
model Role {
  id          String           @id @default(uuid())
  createdAt   DateTime         @default(now())
  updatedAt   DateTime         @updatedAt
  tenantId    String? // null = rôle système (SUPER_ADMIN uniquement)
  name        String // Ex: "ADMIN_RH", "MANAGER", "EMPLOYEE", "CUSTOM_ROLE"
  code        String // Code unique : "ADMIN_RH", "MANAGER", etc.
  description String?
  isSystem    Boolean          @default(false) // Rôle système (non modifiable)
  isActive    Boolean          @default(true)
  tenant      Tenant?          @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  permissions RolePermission[]
  userRoles   UserTenantRole[]

  @@unique([tenantId, code]) // Code unique par tenant (ou global si tenantId null)
  @@index([tenantId])
  @@index([code])
}

// Permission : action atomique (ex: "employee.view_all", "attendance.edit")
model Permission {
  id              String           @id @default(uuid())
  createdAt       DateTime         @default(now())
  updatedAt       DateTime         @updatedAt
  code            String           @unique // Ex: "employee.view_all", "attendance.edit"
  name            String // Nom lisible : "Voir tous les employés"
  description     String?
  category        String // Ex: "employees", "attendance", "leaves", "reports"
  isActive        Boolean          @default(true)
  rolePermissions RolePermission[]

  @@index([category])
  @@index([code])
}

// Liaison n-à-n entre Role et Permission
model RolePermission {
  id           String     @id @default(uuid())
  createdAt    DateTime   @default(now())
  roleId       String
  permissionId String
  role         Role       @relation(fields: [roleId], references: [id], onDelete: Cascade)
  permission   Permission @relation(fields: [permissionId], references: [id], onDelete: Cascade)

  @@unique([roleId, permissionId])
  @@index([roleId])
  @@index([permissionId])
}

// Préférences utilisateur
model UserPreferences {
  id            String   @id @default(uuid())
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  userId        String   @unique
  language      String   @default("fr")
  timezone      String   @default("Africa/Casablanca")
  dateFormat    String   @default("DD/MM/YYYY")
  timeFormat    String   @default("24h")
  notifications Json? // { email: { leaves: boolean, planning: boolean, alerts: boolean }, push: { mobile: boolean, desktop: boolean }, sms: boolean }
  theme         String   @default("light")
  user          User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

// Sessions utilisateur (pour tracking des connexions)
model UserSession {
  id         String   @id @default(uuid())
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
  userId     String
  tokenId    String   @unique // JWT jti (JWT ID) pour identifier le token
  device     String?
  browser    String?
  os         String?
  location   String?
  ipAddress  String?
  userAgent  String?
  lastActive DateTime @default(now())
  expiresAt  DateTime
  isActive   Boolean  @default(true)
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([tokenId])
  @@index([isActive])
}

model UserCredentials {
  id         String    @id @default(uuid())
  createdAt  DateTime  @default(now())
  userId     String    @unique
  employeeId String?   @unique // Optionnel: lien vers l'employé (unique si présent)
  email      String
  password   String // Mot de passe en clair (temporaire, expirera)
  expiresAt  DateTime // Expiration après 7 jours
  viewedAt   DateTime? // Date de dernière consultation
  viewCount  Int       @default(0) // Nombre de fois consulté
  user       User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  employee   Employee? @relation(fields: [employeeId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([employeeId])
  @@index([expiresAt])
}

// Liaison User-Tenant-Role : indique quel utilisateur a quel rôle dans quel tenant
model UserTenantRole {
  id         String   @id @default(uuid())
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
  userId     String
  tenantId   String
  roleId     String
  assignedBy String? // ID de l'utilisateur qui a assigné ce rôle
  assignedAt DateTime @default(now())
  isActive   Boolean  @default(true)
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  tenant     Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  role       Role     @relation(fields: [roleId], references: [id], onDelete: Cascade)

  @@unique([userId, tenantId, roleId]) // Un utilisateur ne peut pas avoir le même rôle deux fois dans le même tenant
  @@index([userId])
  @@index([tenantId])
  @@index([roleId])
}

model ReportHistory {
  id         String   @id @default(uuid())
  createdAt  DateTime @default(now())
  tenantId   String
  userId     String
  reportType String // attendance, overtime, absences, payroll
  format     String // PDF, EXCEL, CSV
  fileName   String
  filePath   String? // Chemin du fichier stocké (optionnel)
  fileSize   Int? // Taille en bytes
  filters    Json? // Filtres utilisés pour générer le rapport
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  tenant     Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@index([tenantId])
  @@index([userId])
  @@index([reportType])
  @@index([createdAt])
}

// Enum LegacyRole : gardé pour compatibilité avec l'ancien système
// Le nouveau système utilise le modèle Role avec UserTenantRole
enum LegacyRole {
  SUPER_ADMIN
  ADMIN_RH
  MANAGER
  EMPLOYEE
}

enum ReplacementStatus {
  PENDING
  APPROVED
  REJECTED
}

enum DeviceType {
  FINGERPRINT
  FACE_RECOGNITION
  RFID_BADGE
  QR_CODE
  PIN_CODE
  MOBILE_GPS
  MANUAL
}

enum AttendanceType {
  IN
  OUT
  BREAK_START
  BREAK_END
  MISSION_START
  MISSION_END
}

enum LeaveStatus {
  PENDING
  MANAGER_APPROVED
  HR_APPROVED
  APPROVED
  REJECTED
  CANCELLED
}

enum OvertimeStatus {
  PENDING
  APPROVED
  REJECTED
  PAID
  RECOVERED
}

enum OvertimeType {
  STANDARD
  NIGHT
  HOLIDAY
  EMERGENCY
}

enum HolidayType {
  NATIONAL
  COMPANY
  RELIGIOUS
}

enum NotificationType {
  SHIFT_CHANGE
  LEAVE_APPROVED
  LEAVE_REJECTED
  OVERTIME_APPROVED
  SCHEDULE_UPDATED
  REPLACEMENT_REQUEST
  ALERT_LEGAL
  SYSTEM
  ATTENDANCE_ANOMALY
  ATTENDANCE_CORRECTED
  ATTENDANCE_APPROVAL_REQUIRED
  TEMPORARY_MATRICULE_EXPIRING
  TEMPORARY_MATRICULE_EXPIRED
}
