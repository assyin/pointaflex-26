generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

model Tenant {
  id                String             @id @default(uuid())
  createdAt         DateTime           @default(now())
  updatedAt         DateTime           @updatedAt
  companyName       String
  slug              String             @unique
  logo              String?
  email             String
  phone             String?
  address           String?
  country           String             @default("MA")
  timezone          String             @default("Africa/Casablanca")
  city              String?
  displayName       String?
  hrEmail           String?
  language          String             @default("fr")
  legalName         String?
  attendance        Attendance[]
  devices           AttendanceDevice[]
  auditLogs         AuditLog[]
  departments       Department[]
  positions         Position[]
  employees         Employee[]
  holidays          Holiday[]
  leaves            Leave[]
  leaveTypes        LeaveType[]
  notifications     Notification[]
  overtime          Overtime[]
  recovery          Recovery[]
  schedules         Schedule[]
  shifts            Shift[]
  shiftReplacements ShiftReplacement[]
  sites             Site[]
  teams             Team[]
  siteManagers      SiteManager[]
  settings          TenantSettings?
  users             User[]
  userTenantRoles   UserTenantRole[]
  roles             Role[] // Rôles personnalisés par tenant (optionnel)

  @@index([slug])
}

model TenantSettings {
  id                       String   @id @default(uuid())
  tenantId                 String   @unique
  workDaysPerWeek          Int      @default(6)
  maxWeeklyHours           Decimal  @default(44)
  breakDuration            Int      @default(60)
  alertWeeklyHoursExceeded Boolean  @default(true)
  alertInsufficientRest    Boolean  @default(true)
  alertNightWorkRepetitive Boolean  @default(true)
  alertMinimumStaffing     Boolean  @default(true)
  annualLeaveDays          Int      @default(18)
  leaveApprovalLevels      Int      @default(2)
  overtimeRate             Decimal  @default(1.25)
  nightShiftRate           Decimal  @default(1.50)
  createdAt                DateTime @default(now())
  updatedAt                DateTime @updatedAt
  anticipatedLeave         Boolean  @default(false)
  earlyToleranceExit       Int      @default(5)
  firstDayOfWeek           String   @default("monday")
  lateToleranceEntry       Int      @default(10)
  monthlyPayrollEmail      Boolean  @default(false)
  nightShiftEnd            String   @default("06:00")
  nightShiftStart          String   @default("21:00")
  overtimeRounding         Int      @default(15)
  sfptExport               Boolean  @default(false)
  twoLevelWorkflow         Boolean  @default(true)
  workingDays              Json?
  tenant                   Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@index([tenantId])
}

model User {
  id              String           @id @default(uuid())
  createdAt       DateTime         @default(now())
  updatedAt       DateTime         @updatedAt
  tenantId        String? // Optionnel pour compatibilité, mais on utilisera UserTenantRole
  email           String           @unique // Email unique globalement
  password        String
  firstName       String
  lastName        String
  phone           String?
  avatar          String?
  isActive        Boolean          @default(true)
  lastLoginAt     DateTime?
  role            LegacyRole?      @default(EMPLOYEE) // Optionnel pour compatibilité
  auditLogs       AuditLog[]
  employee        Employee?
  tenant          Tenant?          @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  userTenantRoles UserTenantRole[]
  preferences     UserPreferences?
  sessions        UserSession[]

  @@index([tenantId])
  @@index([email])
}

model Employee {
  id                        String             @id @default(uuid())
  createdAt                 DateTime           @default(now())
  updatedAt                 DateTime           @updatedAt
  tenantId                  String
  matricule                 String
  firstName                 String
  lastName                  String
  email                     String?
  phone                     String?
  dateOfBirth               DateTime?
  address                   String?
  photo                     String?
  civilite                  String?
  situationFamiliale        String?
  nombreEnfants             Int?
  cnss                      String?
  cin                       String?
  ville                     String?
  rib                       String?
  region                    String?
  categorie                 String?
  position                  String // Texte libre (legacy) - Gardé pour compatibilité
  positionId                String? // Relation vers Position (nouveau)
  hireDate                  DateTime
  contractType              String?
  siteId                    String?
  departmentId              String?
  teamId                    String?
  currentShiftId            String?
  fingerprintData           String?
  faceData                  String?
  rfidBadge                 String?
  qrCode                    String?
  pinCode                   String?
  isActive                  Boolean            @default(true)
  userId                    String?            @unique
  attendance                Attendance[]
  currentShift              Shift?             @relation(fields: [currentShiftId], references: [id])
  department                Department?        @relation(fields: [departmentId], references: [id])
  positionRef               Position?          @relation(fields: [positionId], references: [id])
  site                      Site?              @relation(fields: [siteId], references: [id])
  team                      Team?              @relation(fields: [teamId], references: [id])
  tenant                    Tenant             @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  user                      User?              @relation(fields: [userId], references: [id])
  leaves                    Leave[]
  notifications             Notification[]
  overtime                  Overtime[]
  recovery                  Recovery[]
  schedules                 Schedule[]
  replacementsAsOriginal    ShiftReplacement[] @relation("OriginalEmployee")
  replacementsAsReplacement ShiftReplacement[] @relation("ReplacementEmployee")
  managedTeams              Team[]             @relation("TeamManager")
  managedSites              Site[]             @relation("SiteManagerLegacy") // DEPRECATED
  managedDepartments        Department[]       @relation("DepartmentManager")
  siteManagements           SiteManager[] // Nouvelle relation: gestion de sites par département

  @@unique([tenantId, matricule])
  @@index([tenantId])
  @@index([siteId])
  @@index([departmentId])
  @@index([teamId])
  @@index([positionId])
}

model Site {
  id           String             @id @default(uuid())
  createdAt    DateTime           @default(now())
  updatedAt    DateTime           @updatedAt
  tenantId     String
  name         String
  address      String?
  city         String?
  latitude     Decimal?
  longitude    Decimal?
  code         String?
  phone        String?
  timezone     String?
  workingDays  Json?
  managerId    String? // DEPRECATED: Utiliser SiteManager à la place. Gardé pour rétrocompatibilité
  departmentId String? // ID du département principal du site
  manager      Employee?          @relation("SiteManagerLegacy", fields: [managerId], references: [id])
  department   Department?        @relation("SiteDepartment", fields: [departmentId], references: [id])
  attendance   Attendance[]
  devices      AttendanceDevice[]
  employees    Employee[]
  siteManagers SiteManager[] // Nouvelle relation: plusieurs managers par site (un par département)
  tenant       Tenant             @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@index([tenantId])
  @@index([tenantId, code])
  @@index([managerId])
  @@index([departmentId])
}

model Department {
  id           String        @id @default(uuid())
  createdAt    DateTime      @default(now())
  updatedAt    DateTime      @updatedAt
  tenantId     String
  name         String
  code         String?
  description  String?
  managerId    String? // ID du manager du département
  manager      Employee?     @relation("DepartmentManager", fields: [managerId], references: [id])
  tenant       Tenant        @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  employees    Employee[]
  sites        Site[]        @relation("SiteDepartment")
  siteManagers SiteManager[] // Managers régionaux de ce département dans différents sites

  @@index([tenantId])
  @@index([managerId])
}

// Table de liaison pour permettre plusieurs managers régionaux par site (un par département)
model SiteManager {
  id           String   @id @default(uuid())
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
  tenantId     String
  siteId       String
  managerId    String // ID du manager régional
  departmentId String // ID du département que ce manager gère dans ce site

  site       Site       @relation(fields: [siteId], references: [id], onDelete: Cascade)
  manager    Employee   @relation(fields: [managerId], references: [id], onDelete: Cascade)
  department Department @relation(fields: [departmentId], references: [id], onDelete: Cascade)
  tenant     Tenant     @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@unique([siteId, departmentId]) // Un seul manager par département par site
  @@index([tenantId])
  @@index([siteId])
  @@index([managerId])
  @@index([departmentId])
}

model Position {
  id          String     @id @default(uuid())
  createdAt   DateTime   @default(now())
  updatedAt   DateTime   @updatedAt
  tenantId    String
  name        String // Ex: "Développeur Full-Stack"
  code        String? // Ex: "DEV-FS"
  category    String? // Ex: "IT", "RH", "FINANCE", "PRODUCTION"
  description String?
  tenant      Tenant     @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  employees   Employee[]

  @@index([tenantId])
  @@index([category])
}

model Shift {
  id            String             @id @default(uuid())
  createdAt     DateTime           @default(now())
  updatedAt     DateTime           @updatedAt
  tenantId      String
  name          String
  code          String
  startTime     String
  endTime       String
  breakDuration Int                @default(60)
  isNightShift  Boolean            @default(false)
  color         String?
  employees     Employee[]
  schedules     Schedule[]
  tenant        Tenant             @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  replacements  ShiftReplacement[]

  @@index([tenantId])
}

model Team {
  id                String     @id @default(uuid())
  createdAt         DateTime   @default(now())
  updatedAt         DateTime   @updatedAt
  tenantId          String
  name              String
  code              String
  description       String?
  managerId         String?
  manager           Employee?  @relation("TeamManager", fields: [managerId], references: [id])
  rotationEnabled   Boolean    @default(false)
  rotationCycleDays Int?
  employees         Employee[]
  schedules         Schedule[]
  tenant            Tenant     @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@index([tenantId])
}

model Schedule {
  id              String   @id @default(uuid())
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  tenantId        String
  employeeId      String
  teamId          String?
  shiftId         String
  date            DateTime @db.Date
  customStartTime String?
  customEndTime   String?
  notes           String?
  employee        Employee @relation(fields: [employeeId], references: [id], onDelete: Cascade)
  shift           Shift    @relation(fields: [shiftId], references: [id])
  team            Team?    @relation(fields: [teamId], references: [id])
  tenant          Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@unique([employeeId, date])
  @@index([tenantId])
  @@index([date])
  @@index([employeeId])
}

model ShiftReplacement {
  id                    String            @id @default(uuid())
  createdAt             DateTime          @default(now())
  updatedAt             DateTime          @updatedAt
  tenantId              String
  date                  DateTime          @db.Date
  originalEmployeeId    String
  replacementEmployeeId String
  shiftId               String
  reason                String?
  status                ReplacementStatus @default(PENDING)
  approvedBy            String?
  approvedAt            DateTime?
  originalEmployee      Employee          @relation("OriginalEmployee", fields: [originalEmployeeId], references: [id])
  replacementEmployee   Employee          @relation("ReplacementEmployee", fields: [replacementEmployeeId], references: [id])
  shift                 Shift             @relation(fields: [shiftId], references: [id])
  tenant                Tenant            @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@index([tenantId])
  @@index([date])
}

model AttendanceDevice {
  id         String       @id @default(uuid())
  createdAt  DateTime     @default(now())
  updatedAt  DateTime     @updatedAt
  tenantId   String
  siteId     String?
  name       String
  deviceId   String       @unique
  deviceType DeviceType
  ipAddress  String?
  apiKey     String?
  isActive   Boolean      @default(true)
  lastSync   DateTime?
  attendance Attendance[]
  site       Site?        @relation(fields: [siteId], references: [id])
  tenant     Tenant       @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@index([tenantId])
}

model Attendance {
  id          String            @id @default(uuid())
  createdAt   DateTime          @default(now())
  updatedAt   DateTime          @updatedAt
  tenantId    String
  employeeId  String
  siteId      String?
  deviceId    String?
  timestamp   DateTime
  type        AttendanceType
  method      DeviceType
  latitude    Decimal?
  longitude   Decimal?
  hasAnomaly  Boolean           @default(false)
  anomalyType String?
  anomalyNote String?
  isCorrected Boolean           @default(false)
  correctedBy String?
  correctedAt DateTime?
  rawData     Json?
  generatedBy String?
  isGenerated Boolean           @default(false)
  device      AttendanceDevice? @relation(fields: [deviceId], references: [id])
  employee    Employee          @relation(fields: [employeeId], references: [id], onDelete: Cascade)
  site        Site?             @relation(fields: [siteId], references: [id])
  tenant      Tenant            @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@index([tenantId])
  @@index([employeeId])
  @@index([timestamp])
}

model LeaveType {
  id               String   @id @default(uuid())
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt
  tenantId         String
  name             String
  code             String
  isPaid           Boolean  @default(true)
  requiresDocument Boolean  @default(false)
  maxDaysPerYear   Int?
  leaves           Leave[]
  tenant           Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@index([tenantId])
}

model Leave {
  id                String      @id @default(uuid())
  createdAt         DateTime    @default(now())
  updatedAt         DateTime    @updatedAt
  tenantId          String
  employeeId        String
  leaveTypeId       String
  startDate         DateTime    @db.Date
  endDate           DateTime    @db.Date
  days              Decimal
  reason            String?
  document          String?
  status            LeaveStatus @default(PENDING)
  managerApprovedBy String?
  managerApprovedAt DateTime?
  managerComment    String?
  hrApprovedBy      String?
  hrApprovedAt      DateTime?
  hrComment         String?
  employee          Employee    @relation(fields: [employeeId], references: [id], onDelete: Cascade)
  leaveType         LeaveType   @relation(fields: [leaveTypeId], references: [id])
  tenant            Tenant      @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@index([tenantId])
  @@index([employeeId])
  @@index([startDate])
}

model Overtime {
  id                  String         @id @default(uuid())
  createdAt           DateTime       @default(now())
  updatedAt           DateTime       @updatedAt
  tenantId            String
  employeeId          String
  date                DateTime       @db.Date
  hours               Decimal
  isNightShift        Boolean        @default(false)
  rate                Decimal        @default(1.25)
  convertedToRecovery Boolean        @default(false)
  recoveryId          String?
  status              OvertimeStatus @default(PENDING)
  approvedBy          String?
  approvedAt          DateTime?
  employee            Employee       @relation(fields: [employeeId], references: [id], onDelete: Cascade)
  tenant              Tenant         @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@index([tenantId])
  @@index([employeeId])
}

model Recovery {
  id             String    @id @default(uuid())
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt
  tenantId       String
  employeeId     String
  hours          Decimal
  source         String?
  usedHours      Decimal   @default(0)
  remainingHours Decimal
  expiryDate     DateTime?
  employee       Employee  @relation(fields: [employeeId], references: [id], onDelete: Cascade)
  tenant         Tenant    @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@index([tenantId])
  @@index([employeeId])
}

model Holiday {
  id          String      @id @default(uuid())
  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @updatedAt
  tenantId    String
  name        String
  date        DateTime    @db.Date
  isRecurring Boolean     @default(false)
  type        HolidayType @default(NATIONAL)
  tenant      Tenant      @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@index([tenantId])
  @@index([date])
}

model AuditLog {
  id        String   @id @default(uuid())
  createdAt DateTime @default(now())
  tenantId  String
  userId    String?
  action    String
  entity    String
  entityId  String?
  oldValues Json?
  newValues Json?
  ipAddress String?
  userAgent String?
  tenant    Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  user      User?    @relation(fields: [userId], references: [id])

  @@index([tenantId])
  @@index([createdAt])
  @@index([entity])
}

model Notification {
  id         String           @id @default(uuid())
  createdAt  DateTime         @default(now())
  updatedAt  DateTime         @updatedAt
  tenantId   String
  employeeId String
  type       NotificationType
  title      String
  message    String
  isRead     Boolean          @default(false)
  readAt     DateTime?
  metadata   Json?
  employee   Employee         @relation(fields: [employeeId], references: [id], onDelete: Cascade)
  tenant     Tenant           @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@index([tenantId])
  @@index([employeeId])
  @@index([isRead])
}

// ============================================
// RBAC Multi-Tenant Models
// ============================================

// Rôle : peut être système (SUPER_ADMIN) ou spécifique à un tenant
model Role {
  id          String           @id @default(uuid())
  createdAt   DateTime         @default(now())
  updatedAt   DateTime         @updatedAt
  tenantId    String? // null = rôle système (SUPER_ADMIN uniquement)
  name        String // Ex: "ADMIN_RH", "MANAGER", "EMPLOYEE", "CUSTOM_ROLE"
  code        String // Code unique : "ADMIN_RH", "MANAGER", etc.
  description String?
  isSystem    Boolean          @default(false) // Rôle système (non modifiable)
  isActive    Boolean          @default(true)
  tenant      Tenant?          @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  permissions RolePermission[]
  userRoles   UserTenantRole[]

  @@unique([tenantId, code]) // Code unique par tenant (ou global si tenantId null)
  @@index([tenantId])
  @@index([code])
}

// Permission : action atomique (ex: "employee.view_all", "attendance.edit")
model Permission {
  id              String           @id @default(uuid())
  createdAt       DateTime         @default(now())
  updatedAt       DateTime         @updatedAt
  code            String           @unique // Ex: "employee.view_all", "attendance.edit"
  name            String // Nom lisible : "Voir tous les employés"
  description     String?
  category        String // Ex: "employees", "attendance", "leaves", "reports"
  isActive        Boolean          @default(true)
  rolePermissions RolePermission[]

  @@index([category])
  @@index([code])
}

// Liaison n-à-n entre Role et Permission
model RolePermission {
  id           String     @id @default(uuid())
  createdAt    DateTime   @default(now())
  roleId       String
  permissionId String
  role         Role       @relation(fields: [roleId], references: [id], onDelete: Cascade)
  permission   Permission @relation(fields: [permissionId], references: [id], onDelete: Cascade)

  @@unique([roleId, permissionId])
  @@index([roleId])
  @@index([permissionId])
}

// Préférences utilisateur
model UserPreferences {
  id            String   @id @default(uuid())
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  userId        String   @unique
  language      String   @default("fr")
  timezone      String   @default("Africa/Casablanca")
  dateFormat    String   @default("DD/MM/YYYY")
  timeFormat    String   @default("24h")
  notifications Json? // { email: { leaves: boolean, planning: boolean, alerts: boolean }, push: { mobile: boolean, desktop: boolean }, sms: boolean }
  theme         String   @default("light")
  user          User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

// Sessions utilisateur (pour tracking des connexions)
model UserSession {
  id         String   @id @default(uuid())
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
  userId     String
  tokenId    String   @unique // JWT jti (JWT ID) pour identifier le token
  device     String?
  browser    String?
  os         String?
  location   String?
  ipAddress  String?
  userAgent  String?
  lastActive DateTime @default(now())
  expiresAt  DateTime
  isActive   Boolean  @default(true)
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([tokenId])
  @@index([isActive])
}

// Liaison User-Tenant-Role : indique quel utilisateur a quel rôle dans quel tenant
model UserTenantRole {
  id         String   @id @default(uuid())
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
  userId     String
  tenantId   String
  roleId     String
  assignedBy String? // ID de l'utilisateur qui a assigné ce rôle
  assignedAt DateTime @default(now())
  isActive   Boolean  @default(true)
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  tenant     Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  role       Role     @relation(fields: [roleId], references: [id], onDelete: Cascade)

  @@unique([userId, tenantId, roleId]) // Un utilisateur ne peut pas avoir le même rôle deux fois dans le même tenant
  @@index([userId])
  @@index([tenantId])
  @@index([roleId])
}

// Enum LegacyRole : gardé pour compatibilité avec l'ancien système
// Le nouveau système utilise le modèle Role avec UserTenantRole
enum LegacyRole {
  SUPER_ADMIN
  ADMIN_RH
  MANAGER
  EMPLOYEE
}

enum ReplacementStatus {
  PENDING
  APPROVED
  REJECTED
}

enum DeviceType {
  FINGERPRINT
  FACE_RECOGNITION
  RFID_BADGE
  QR_CODE
  PIN_CODE
  MOBILE_GPS
  MANUAL
}

enum AttendanceType {
  IN
  OUT
  BREAK_START
  BREAK_END
  MISSION_START
  MISSION_END
}

enum LeaveStatus {
  PENDING
  MANAGER_APPROVED
  HR_APPROVED
  APPROVED
  REJECTED
  CANCELLED
}

enum OvertimeStatus {
  PENDING
  APPROVED
  REJECTED
}

enum HolidayType {
  NATIONAL
  COMPANY
  RELIGIOUS
}

enum NotificationType {
  SHIFT_CHANGE
  LEAVE_APPROVED
  LEAVE_REJECTED
  OVERTIME_APPROVED
  SCHEDULE_UPDATED
  REPLACEMENT_REQUEST
  ALERT_LEGAL
  SYSTEM
}
